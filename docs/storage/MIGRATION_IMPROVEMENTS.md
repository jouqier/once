# Улучшения логики миграции данных

## Проблема: конфликты данных при миграции с разных устройств

### Текущая ситуация

При миграции данных из `localStorage` в CloudStorage существует риск потери данных, если пользователь использует несколько устройств с разными данными.

### Проблемные сценарии

#### Сценарий 1: Последовательная миграция
- **Устройство A** мигрирует первым → ставит флаг `migrated = true`
- **Устройство B** видит флаг → пропускает миграцию
- **Результат:** Данные устройства B теряются ❌

#### Сценарий 2: Одновременная миграция (race condition)
- Оба устройства проверяют CloudStorage одновременно → оба видят пусто
- Оба мигрируют → последний перезаписывает данные первого
- **Результат:** Данные одного устройства теряются ❌

#### Сценарий 3: Разные данные на устройствах
- **Устройство A:** фильм ID 100 в списке "watched"
- **Устройство B:** фильм ID 200 в списке "watched"
- При миграции: одно устройство перезапишет данные другого
- **Результат:** Один из фильмов теряется ❌

### Текущая логика миграции

В `cloud-storage-migration.js` есть проверка:

```javascript
// Проверяем, есть ли данные в CloudStorage
if (cloudUserKeys.length > 0) {
    console.log(`В CloudStorage уже есть ${cloudUserKeys.length} ключей, пропускаем миграцию`);
    // Помечаем миграцию как выполненную
    await cloudAdapter.setItem(migrationFlagKey, 'true');
    return true;
}
```

**Проблема:** Если данные уже есть в CloudStorage, локальные данные игнорируются полностью.

---

## План улучшений

### 1. Стратегия объединения данных

Вместо перезаписи данных нужно объединять их:

#### Для списков (фильмы, сериалы, подписки)
- Объединять массивы ID без дубликатов
- Пример: `[100, 200]` + `[200, 300]` → `[100, 200, 300]`

#### Для отзывов
- Сохранять оба отзыва, если ID разные
- Если ID одинаковый → использовать более новый (по дате)
- Пример: `{100: review1}` + `{200: review2}` → `{100: review1, 200: review2}`

#### Для эпизодов
- Объединять просмотренные эпизоды из разных сезонов
- Для одного сезона: объединять массивы эпизодов
- Пример: `{100: {1: [1,2,3]}}` + `{100: {2: [1,2]}}` → `{100: {1: [1,2,3], 2: [1,2]}}`

### 2. Улучшенная логика миграции

```javascript
async migrateToCloudStorage(userId) {
    // ... существующие проверки ...
    
    // Если данные уже есть в CloudStorage - объединяем
    if (cloudUserKeys.length > 0) {
        console.log('Обнаружены данные в CloudStorage, выполняем объединение...');
        return await this.mergeLocalDataWithCloud(userId);
    }
    
    // Если данных нет - мигрируем как обычно
    return await this.migrateFreshData(userId);
}
```

### 3. Метод объединения данных

```javascript
async mergeLocalDataWithCloud(userId) {
    const cloudAdapter = new CloudStorageAdapter();
    const prefix = `user_${userId}_`;
    
    // Загружаем данные из CloudStorage
    const cloudData = await this.loadCloudData(cloudAdapter, prefix);
    
    // Загружаем данные из localStorage
    const localData = await this.loadLocalData(prefix);
    
    // Объединяем данные
    const mergedData = this.mergeData(cloudData, localData);
    
    // Сохраняем объединенные данные обратно в CloudStorage
    await this.saveMergedData(cloudAdapter, mergedData);
    
    // Помечаем миграцию как выполненную
    await cloudAdapter.setItem(`${prefix}migrated`, 'true');
    
    return true;
}
```

### 4. Функции объединения по типам данных

#### Объединение списков фильмов/сериалов
```javascript
mergeLists(cloudList, localList) {
    // Объединяем массивы ID без дубликатов
    return [...new Set([...cloudList, ...localList])];
}
```

#### Объединение отзывов
```javascript
mergeReviews(cloudReviews, localReviews) {
    const merged = { ...cloudReviews };
    
    Object.entries(localReviews).forEach(([id, review]) => {
        if (!merged[id]) {
            // Новый отзыв - добавляем
            merged[id] = review;
        } else {
            // Отзыв уже есть - используем более новый
            const cloudDate = new Date(merged[id].date);
            const localDate = new Date(review.date);
            if (localDate > cloudDate) {
                merged[id] = review;
            }
        }
    });
    
    return merged;
}
```

#### Объединение эпизодов
```javascript
mergeEpisodes(cloudEpisodes, localEpisodes) {
    const merged = { ...cloudEpisodes };
    
    Object.entries(localEpisodes).forEach(([tvId, tvData]) => {
        if (!merged[tvId]) {
            merged[tvId] = { ...tvData };
        } else {
            // Объединяем сезоны
            Object.entries(tvData).forEach(([season, episodes]) => {
                if (!merged[tvId][season]) {
                    merged[tvId][season] = episodes;
                } else {
                    // Объединяем эпизоды сезона
                    const cloudEps = Array.isArray(merged[tvId][season]) 
                        ? merged[tvId][season] 
                        : this.parseEpisodes(merged[tvId][season]);
                    const localEps = Array.isArray(episodes) 
                        ? episodes 
                        : this.parseEpisodes(episodes);
                    merged[tvId][season] = [...new Set([...cloudEps, ...localEps])];
                }
            });
        }
    });
    
    return merged;
}
```

### 5. Обработка race condition

Для предотвращения одновременной миграции можно использовать:

#### Вариант A: Версионирование
- Добавить поле `migration_version` в метаданные
- При миграции проверять версию и обновлять только если локальная версия новее

#### Вариант B: Таймстамп последнего изменения
- Сохранять `last_modified` для каждого ключа
- При объединении использовать более свежие данные

#### Вариант C: Оптимистичная блокировка
- Использовать флаг `migrating` в CloudStorage
- Устанавливать флаг перед миграцией, снимать после
- Если флаг установлен другим устройством - ждать и повторить

### 6. Логирование и отладка

Добавить детальное логирование:
- Какие данные были объединены
- Сколько элементов добавлено/обновлено
- Какие конфликты были разрешены

---

## Приоритет реализации

1. **Высокий приоритет:**
   - Объединение списков фильмов/сериалов
   - Объединение подписок на персон
   - Объединение отзывов

2. **Средний приоритет:**
   - Объединение эпизодов
   - Обработка race condition

3. **Низкий приоритет:**
   - Детальное логирование
   - Статистика объединений

---

## Оценка трудозатрат

- Реализация объединения данных: ~4-6 часов
- Тестирование на разных устройствах: ~2-3 часа
- Обработка edge cases: ~2 часа

**Итого:** ~8-11 часов работы

---

## Риски

1. **Сложность тестирования:** Трудно воспроизвести конфликты на разных устройствах
2. **Производительность:** Объединение больших объемов данных может быть медленным
3. **Обратная совместимость:** Нужно убедиться, что старые данные не потеряются

---

## Альтернативные решения

### Вариант 1: Предупреждение пользователя
Показывать предупреждение при обнаружении конфликта и предлагать выбрать источник данных.

### Вариант 2: Резервное копирование
Перед миграцией создавать резервную копию данных в CloudStorage.

### Вариант 3: Постепенная миграция
Мигрировать данные постепенно, проверяя конфликты на каждом этапе.

---

## Дата создания
2024-12-19

## Статус
Планируется

