# Стратегия хранения эпизодов сериалов в CloudStorage

## Анализ конкретного случая

**Параметры:**
- 500 эпизодов всего
- 23 сезона
- ~21-22 эпизода в среднем на сезон
- Один сезон с 30 эпизодами

## Сравнение вариантов хранения

### Вариант 1: Один ключ на сезон (23 ключа)

```javascript
{
    "tv_ep_100_1": [1,2,3,...,29],    // 79 символов
    "tv_ep_100_2": [1,2,3,...,21],    // 55 символов
    "tv_ep_100_3": [1,2,3,...,21],    // 55 символов
    // ... 23 ключа
}
```

**Результат:**
- ✅ Каждый ключ очень маленький (55-82 символа)
- ❌ **23 ключа** - неэффективно использует лимит (1024 ключа)
- ❌ Больше запросов к CloudStorage

### Вариант 2: Один ключ на весь сериал (1 ключ) ⭐ РЕКОМЕНДУЕТСЯ

```javascript
{
    "tv_ep_100": {
        "1": [1,2,3,...,29],
        "2": [1,2,3,...,21],
        "3": [1,2,3,...,21],
        // ... все 23 сезона
    }
}
```

**Результат:**
- ✅ **1 ключ** - оптимально
- ✅ **1422 символа** - отлично влезает в 4096
- ✅ Один запрос для загрузки всех эпизодов
- ✅ Простая структура данных

### Вариант 3: Компактный формат с диапазонами (1 ключ) ⭐ ОПТИМАЛЬНО

```javascript
{
    "tv_ep_100": {
        "1": [1, 29],        // Диапазон: все эпизоды просмотрены
        "2": [1, 21],        // Диапазон: все эпизоды просмотрены
        "3": [1, 2, 5, 7, 21], // Массив: просмотрены не все
        // ...
    }
}
```

**Результат:**
- ✅ **1 ключ** - оптимально
- ✅ **498 символов** - очень компактно (если все сезоны просмотрены полностью)
- ✅ Автоматическое определение формата:
  - Если все эпизоды подряд → диапазон `[1, 30]`
  - Если пропуски → массив `[1, 2, 5, 7, ...]`

## Рекомендуемая стратегия

### Базовый подход: Один ключ на сериал

```javascript
// Ключ: tv_ep_{tvId}
// Значение: { season: episodes[] | [start, end] }
{
    "tv_ep_100": {
        "1": [1, 29],           // Диапазон (все просмотрены)
        "2": [1, 21],           // Диапазон (все просмотрены)
        "3": [1, 2, 5, 7, 21],  // Массив (есть пропуски)
        "12": [1, 30]           // Большой сезон (30 эпизодов)
    }
}
```

### Логика определения формата

```javascript
function formatEpisodes(episodes) {
    // Если все эпизоды просмотрены подряд
    if (episodes.length > 0 && 
        episodes[0] === 1 && 
        episodes[episodes.length - 1] === episodes.length) {
        // Используем диапазон
        return [1, episodes.length];
    }
    // Иначе массив
    return episodes;
}

function parseEpisodes(data) {
    if (Array.isArray(data) && data.length === 2) {
        // Диапазон: [1, 30] → [1,2,3,...,30]
        return Array.from({length: data[1]}, (_, i) => i + 1);
    }
    // Массив: [1, 2, 5, 7]
    return data;
}
```

### Автоматическое разбиение (если не влезает)

```javascript
function saveEpisodes(tvId, seasons) {
    const data = {};
    seasons.forEach(s => {
        data[s.season] = formatEpisodes(s.episodes);
    });
    
    const json = JSON.stringify(data);
    
    if (json.length <= 4096) {
        // Один ключ на весь сериал
        return { key: `tv_ep_${tvId}`, value: json };
    } else {
        // Разбить на группы сезонов
        return splitIntoGroups(tvId, seasons);
    }
}

function splitIntoGroups(tvId, seasons) {
    const groups = [];
    let currentGroup = {};
    let currentSize = 2; // "{"
    
    seasons.forEach(s => {
        const seasonData = formatEpisodes(s.episodes);
        const json = JSON.stringify({ [s.season]: seasonData });
        const size = json.length - 2; // Убираем фигурные скобки
        
        if (currentSize + size + 1 < 3500) { // +1 для запятой
            currentGroup[s.season] = seasonData;
            currentSize += size + 1;
        } else {
            // Сохраняем текущую группу
            if (Object.keys(currentGroup).length > 0) {
                groups.push({
                    key: `tv_ep_${tvId}_g${groups.length}`,
                    value: JSON.stringify(currentGroup)
                });
            }
            // Начинаем новую группу
            currentGroup = { [s.season]: seasonData };
            currentSize = size;
        }
    });
    
    // Сохраняем последнюю группу
    if (Object.keys(currentGroup).length > 0) {
        groups.push({
            key: `tv_ep_${tvId}_g${groups.length}`,
            value: JSON.stringify(currentGroup)
        });
    }
    
    return groups;
}
```

## Оценка для разных сценариев

### Сценарий 1: 500 эпизодов, 23 сезона (текущий случай)
- **Вариант:** Один ключ на сериал
- **Размер:** 1422 символа (обычный) или 498 символов (компактный)
- **Ключей:** 1
- **Статус:** ✅ Оптимально

### Сценарий 2: 1000 эпизодов, 50 сезонов
- **Вариант:** Один ключ на сериал
- **Размер:** ~3000 символов (обычный) или ~1000 символов (компактный)
- **Ключей:** 1
- **Статус:** ✅ OK

### Сценарий 3: 2000 эпизодов, 100 сезонов
- **Вариант:** Один ключ на сериал (компактный формат)
- **Размер:** ~2000 символов (компактный)
- **Ключей:** 1
- **Статус:** ✅ OK

### Сценарий 4: 5000 эпизодов, 200 сезонов
- **Вариант:** Разбиение на группы
- **Размер:** ~4000 символов на группу
- **Ключей:** 2-3
- **Статус:** ✅ OK

## Итоговые рекомендации

### ✅ Оптимальная стратегия:

1. **Один ключ на сериал** (`tv_ep_{tvId}`)
   - Хранить все сезоны в одном объекте
   - Использовать компактный формат (диапазоны) когда возможно

2. **Автоматическое определение формата:**
   - Если все эпизоды сезона просмотрены подряд → диапазон `[1, 30]`
   - Если есть пропуски → массив `[1, 2, 5, 7, ...]`

3. **Автоматическое разбиение:**
   - Если размер > 3500 символов → разбить на группы сезонов
   - Группы по ~3500 символов каждая

4. **Метаданные (опционально):**
   - `tv_ep_{tvId}_meta` → `{"totalSeasons": 23, "totalEpisodes": 500, "groups": 1}`

### Преимущества:

- ✅ Минимум ключей (1 на сериал)
- ✅ Минимум запросов (1 запрос для загрузки)
- ✅ Компактное хранение (диапазоны вместо массивов)
- ✅ Масштабируемость (автоматическое разбиение при необходимости)
- ✅ Простота работы (один ключ = один сериал)

### Пример использования:

```javascript
// Сохранение
const episodes = {
    1: [1, 29],      // Все просмотрены
    2: [1, 21],      // Все просмотрены
    3: [1, 2, 5, 7], // Частично просмотрены
    // ...
};
await cloudStorage.setItem(`tv_ep_100`, JSON.stringify(episodes));

// Загрузка
const data = await cloudStorage.getItem(`tv_ep_100`);
const episodes = JSON.parse(data);
```

