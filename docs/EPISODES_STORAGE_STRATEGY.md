# Стратегия хранения эпизодов сериалов для CloudStorage

## Текущая реализация (версия 1.4)

**Реализованная стратегия:** Все эпизоды всех сериалов в одном ключе с компактным форматом и автоматическим разбиением на группы.

### Структура хранения

```javascript
// Ключ: user_{userId}_tv_episodes
// Значение: { tvId: { season: episodes[] | [start, end] } }
{
    "100": {                      // tvId сериала
        "1": [1, 29],             // Сезон 1: диапазон (все эпизоды 1-29 просмотрены)
        "2": [1, 21],             // Сезон 2: диапазон (все эпизоды 1-21 просмотрены)
        "3": [1, 2, 5, 7, 21]     // Сезон 3: массив (есть пропуски)
    },
    "200": {                      // Другой сериал
        "1": [1, 10],
        "2": [1, 3, 7, 10]
    }
}
```

### Преимущества реализованной стратегии

1. ✅ **Минимум ключей** - все эпизоды всех сериалов в одном ключе
2. ✅ **Минимум запросов** - один запрос для загрузки всех данных
3. ✅ **Компактное хранение** - диапазоны экономят ~95% места
4. ✅ **Автоматическое разбиение** - группы создаются при превышении 4096 символов
5. ✅ **Простота работы** - логическая структура сохранена

## Анализ конкретных случаев

### Случай 1: Один сериал (500 эпизодов, 23 сезона)

**Параметры:**
- 500 эпизодов всего
- 23 сезона
- ~21-22 эпизода в среднем на сезон
- Один сезон с 30 эпизодами

**Размер данных:**

| Формат | Размер | Статус |
|--------|--------|--------|
| Массивы (обычный) | ~1422 символа | ✅ OK |
| Диапазоны (компактный) | ~498 символов | ✅ OK |

**Вывод:** Отлично влезает в один ключ с большим запасом!

### Случай 2: Несколько сериалов (10 сериалов, ~200 эпизодов каждый)

**Параметры:**
- 10 сериалов
- ~200 эпизодов на сериал
- ~10 сезонов на сериал

**Размер данных:**

| Формат | Размер | Статус |
|--------|--------|--------|
| Массивы (обычный) | ~2800 символов | ✅ OK |
| Диапазоны (компактный) | ~1000 символов | ✅ OK |

**Вывод:** Все данные влезают в один ключ!

### Случай 3: Много сериалов (50 сериалов, ~100 эпизодов каждый)

**Параметры:**
- 50 сериалов
- ~100 эпизодов на сериал
- ~5 сезонов на сериал

**Размер данных:**

| Формат | Размер | Статус |
|--------|--------|--------|
| Массивы (обычный) | ~7000 символов | ❌ Превышение |
| Диапазоны (компактный) | ~2500 символов | ✅ OK |
| **Автоматическое разбиение** | **2 группы по ~3500 символов** | ✅ OK |

**Вывод:** Автоматически разбивается на 2 группы.

## Реализованная логика

### Компактный формат эпизодов

```javascript
// Реализовано в StorageAdapter
function formatEpisodes(episodes) {
    // Если все эпизоды просмотрены подряд с 1
    if (episodes.length > 0 && 
        episodes[0] === 1 && 
        episodes[episodes.length - 1] === episodes.length) {
        // Используем диапазон [start, end]
        return [1, episodes.length];
    }
    // Иначе массив
    return episodes;
}

function parseEpisodes(data) {
    if (Array.isArray(data) && data.length === 2) {
        // Диапазон: [1, 30] → [1,2,3,...,30]
        return Array.from({length: data[1]}, (_, i) => i + 1);
    }
    // Массив: [1, 2, 5, 7]
    return data;
}
```

### Автоматическое разбиение на группы

```javascript
// Реализовано в StorageAdapter
function saveEpisodes(userId, allEpisodes) {
    const json = JSON.stringify(allEpisodes);
    
    if (json.length <= 4096) {
        // Один ключ для всех эпизодов
        localStorage.setItem(`user_${userId}_tv_episodes`, json);
    } else {
        // Разбить на группы
        const groups = splitIntoGroups(allEpisodes);
        groups.forEach((group, index) => {
            localStorage.setItem(
                `user_${userId}_tv_episodes_g${index}`, 
                JSON.stringify(group)
            );
        });
    }
}

function splitIntoGroups(allEpisodes) {
    const groups = [];
    let currentGroup = {};
    let currentSize = 2; // "{}"
    
    for (const [tvId, seasons] of Object.entries(allEpisodes)) {
        const tvData = JSON.stringify({ [tvId]: seasons });
        const tvSize = tvData.length - 2; // Убираем фигурные скобки
        
        if (currentSize + tvSize + 1 < 3500) { // +1 для запятой
            currentGroup[tvId] = seasons;
            currentSize += tvSize + 1;
        } else {
            // Сохраняем текущую группу
            if (Object.keys(currentGroup).length > 0) {
                groups.push(currentGroup);
            }
            // Начинаем новую группу
            currentGroup = { [tvId]: seasons };
            currentSize = tvSize + 2;
        }
    }
    
    // Сохраняем последнюю группу
    if (Object.keys(currentGroup).length > 0) {
        groups.push(currentGroup);
    }
    
    return groups;
}

function loadEpisodes(userId) {
    // Попытка загрузить из одного ключа
    let data = localStorage.getItem(`user_${userId}_tv_episodes`);
    if (data) {
        return JSON.parse(data);
    }
    
    // Загрузка из групп
    const allEpisodes = {};
    let groupIndex = 0;
    
    while (true) {
        const groupData = localStorage.getItem(
            `user_${userId}_tv_episodes_g${groupIndex}`
        );
        if (!groupData) break;
        
        const group = JSON.parse(groupData);
        Object.assign(allEpisodes, group);
        groupIndex++;
    }
    
    return allEpisodes;
}
```

## Оценка для разных сценариев пользователей

### Сценарий 1: Новый пользователь (1-5 сериалов)
- **Сериалов:** 1-5
- **Эпизодов:** 50-250
- **Размер (компактный):** ~100-500 символов
- **Ключей:** 1
- **Статус:** ✅ Оптимально

### Сценарий 2: Активный пользователь (10-20 сериалов)
- **Сериалов:** 10-20
- **Эпизодов:** 500-1000
- **Размер (компактный):** ~1000-2000 символов
- **Ключей:** 1
- **Статус:** ✅ OK

### Сценарий 3: Очень активный пользователь (30-50 сериалов)
- **Сериалов:** 30-50
- **Эпизодов:** 1500-2500
- **Размер (компактный):** ~2500-3500 символов
- **Ключей:** 1
- **Статус:** ✅ OK

### Сценарий 4: Коллекционер (50-100 сериалов)
- **Сериалов:** 50-100
- **Эпизодов:** 2500-5000
- **Размер (компактный):** ~4000-7000 символов
- **Ключей:** 2-3 (автоматическое разбиение)
- **Статус:** ✅ OK

### Сценарий 5: Экстремальный случай (100+ сериалов)
- **Сериалов:** 100+
- **Эпизодов:** 5000+
- **Размер (компактный):** ~7000+ символов
- **Ключей:** 3-5 (автоматическое разбиение)
- **Статус:** ✅ OK

## Реализованная стратегия (версия 1.4)

### ✅ Текущая реализация:

1. **Все эпизоды всех сериалов в одном ключе** (`user_{userId}_tv_episodes`)
   - Структура: `{ tvId: { season: episodes[] | [start, end] } }`
   - Все сериалы пользователя в одном месте

2. **Автоматическое определение формата:**
   - Если все эпизоды сезона просмотрены подряд → диапазон `[1, 30]`
   - Если есть пропуски → массив `[1, 2, 5, 7, ...]`
   - Реализовано в `StorageAdapter`

3. **Автоматическое разбиение на группы:**
   - Если размер > 4096 символов → разбить на группы
   - Группы: `tv_episodes_g0`, `tv_episodes_g1`, и т.д.
   - Автоматическая загрузка из всех групп

4. **Прозрачная работа:**
   - `UserDataStore` работает с логической структурой
   - `StorageAdapter` автоматически управляет группами
   - Разработчик не думает о разбиении

### Преимущества реализации:

- ✅ **Минимум ключей** - 1 ключ для всех эпизодов (или 2-5 при разбиении)
- ✅ **Минимум запросов** - 1 запрос для загрузки всех данных
- ✅ **Компактное хранение** - диапазоны экономят ~95% места
- ✅ **Масштабируемость** - автоматическое разбиение при необходимости
- ✅ **Простота работы** - прозрачная абстракция
- ✅ **Готовность к CloudStorage** - структура полностью совместима

### Пример использования:

```javascript
// Сохранение эпизода (автоматически)
userDataStore.setEpisodeStatus(100, 1, 5, true);
// Внутри:
// 1. Загружает все эпизоды из tv_episodes (или групп)
// 2. Обновляет эпизод
// 3. Определяет формат (диапазон или массив)
// 4. Сохраняет обратно (с разбиением на группы если нужно)

// Загрузка эпизодов сезона
const episodes = userDataStore.getSeasonEpisodes(100, 1);
// Возвращает: [1, 2, 3, 4, 5] (автоматически парсит диапазон)

// Проверка статуса эпизода
const isWatched = userDataStore.getEpisodeStatus(100, 1, 5);
// Возвращает: true
```

### Миграция на CloudStorage:

```javascript
// Текущая структура уже готова!
// Нужно только заменить localStorage на CloudStorage API

// localStorage (текущее)
localStorage.setItem('user_123_tv_episodes', JSON.stringify(episodes));

// CloudStorage (будущее)
await cloudStorage.setItem('user_123_tv_episodes', JSON.stringify(episodes));

// Структура данных остается той же!
```

## Сравнение с альтернативными подходами

### Подход 1: Один ключ на сезон (отклонен)

```javascript
// 23 ключа для одного сериала
'user_123_tv_ep_100_1': '[1,2,3,...,29]'
'user_123_tv_ep_100_2': '[1,2,3,...,21]'
// ...
```

**Недостатки:**
- ❌ Много ключей (23 на сериал)
- ❌ Много запросов (23 запроса для загрузки)
- ❌ Сложность управления

### Подход 2: Один ключ на сериал (отклонен)

```javascript
// 1 ключ на сериал
'user_123_tv_ep_100': '{"1":[1,29],"2":[1,21],...}'
'user_123_tv_ep_200': '{"1":[1,10],...}'
```

**Недостатки:**
- ⚠️ Много ключей (1 на сериал)
- ⚠️ Много запросов (N запросов для N сериалов)
- ⚠️ Сложность при загрузке всех данных

### Подход 3: Все в одном ключе (реализован) ✅

```javascript
// 1 ключ для всех эпизодов
'user_123_tv_episodes': '{"100":{"1":[1,29],"2":[1,21]},"200":{"1":[1,10]}}'
```

**Преимущества:**
- ✅ Минимум ключей (1 или 2-5 при разбиении)
- ✅ Минимум запросов (1 запрос)
- ✅ Простота управления
- ✅ Компактный формат
- ✅ Автоматическое разбиение

## Вывод

Реализованная стратегия версии 1.4 является оптимальной для CloudStorage:

1. **Минимизирует количество ключей** - важно для лимита 1024 ключа
2. **Минимизирует количество запросов** - важно для производительности
3. **Максимизирует компактность** - диапазоны экономят ~95% места
4. **Автоматически масштабируется** - разбиение на группы при необходимости
5. **Прозрачна для разработчика** - абстракция скрывает сложность

**Готовность к миграции:** 100% - требуется только рефакторинг на асинхронный API.

