# Документация по хранению данных

## Обзор

Приложение использует двухуровневую систему хранения данных:
1. **Пользовательские данные** - критичные данные, хранятся в `localStorage`
2. **Кеш данных API** - временные данные из TMDB API, хранятся в `localStorage` и памяти

## Архитектура хранения

### 1. Пользовательские данные (UserDataStore)

#### Место хранения
- **localStorage**: Разбитая структура ключей для оптимизации (версия 1.4)
- **sessionStorage**: `user_id` - временное хранение ID пользователя для быстрого доступа
- **sessionStorage**: `recent_searches_${userId}` - недавние поиски

#### Структура ключей (версия 1.4)

Данные хранятся в разбитом виде для оптимизации использования ключей и подготовки к CloudStorage:

```
user_{userId}_meta                    - Метаданные (version, userId)
user_{userId}_movies_want            - Массив ID фильмов "хочу посмотреть"
user_{userId}_movies_watched         - Массив ID фильмов "просмотрено"
user_{userId}_movies_reviews         - Все отзывы на фильмы (объект {id: review})
                                       Если не влезает → movies_reviews_g0, movies_reviews_g1, ...
user_{userId}_tv_want                - Массив ID сериалов "хочу посмотреть"
user_{userId}_tv_watching            - Массив ID сериалов "смотрю"
user_{userId}_tv_watched             - Массив ID сериалов "просмотрено"
user_{userId}_tv_season_reviews      - Все отзывы на сезоны (объект {"tvId_season": review})
                                       Если не влезает → tv_season_reviews_g0, tv_season_reviews_g1, ...
user_{userId}_tv_episodes            - Все эпизоды всех сериалов (объект {tvId: {season: episodes[]}})
                                       Если не влезает → tv_episodes_g0, tv_episodes_g1, ...
user_{userId}_tv_episodes_meta       - Метаданные для эпизодов (groups) - опционально
```

#### Структура данных (логическое представление)

```javascript
{
    version: "1.4",              // Версия структуры данных (разбитая структура)
    userId: "123456789",         // ID пользователя Telegram
    movies: {
        want: [1, 2, 3],          // Массив ID фильмов в списке "Хочу посмотреть"
        watched: [4, 5, 6],       // Массив ID фильмов в списке "Просмотрено"
        reviews: {                // Отзывы на фильмы (группированные)
            "123": {
                rating: 5,
                review: "Отличный фильм!",
                date: "2024-01-15T10:30:00.000Z"
            }
        }
    },
    tvShows: {
        want: [10, 20],           // Массив ID сериалов в списке "Хочу посмотреть"
        watching: [30, 40],       // Массив ID сериалов в списке "Смотрю"
        watched: [50, 60],        // Массив ID сериалов в списке "Просмотрено"
        episodes: {               // Просмотренные эпизоды (все сериалы в одном ключе)
            "100": {              // tvId
                "1": [1, 29],     // Сезон 1: диапазон [1, 29] (все просмотрены)
                "2": [1, 21],     // Сезон 2: диапазон [1, 21] (все просмотрены)
                "3": [1, 2, 5, 7, 21]  // Сезон 3: массив (есть пропуски)
            }
        },
        seasonReviews: {          // Отзывы на сезоны (группированные)
            "100_1": {            // Формат: "tvId_season"
                rating: 5,
                review: "Отличный сезон!",
                date: "2024-01-15T10:30:00.000Z"
            }
        }
    },
    // search.recent хранится в sessionStorage, не в localStorage
}
```

#### Особенности хранения

1. **Оптимизация размера**: Хранятся только ID фильмов и сериалов, а не полные объекты
   - Экономия места: вместо ~500 байт на фильм хранится только ~4 байта (ID)
   - Полные данные загружаются из TMDB API по требованию

2. **Разделение фильмов и сериалов**: 
   - Фильмы: только `want` и `watched` (не могут быть в `watching`)
   - Сериалы: `want`, `watching`, `watched`

3. **Хранение эпизодов** (оптимизировано):
   - Все эпизоды всех сериалов хранятся в одном ключе `tv_episodes`
   - Структура: `{tvId: {season: episodes[] | [start, end]}}`
   - Компактный формат:
     - Если все эпизоды сезона просмотрены подряд → диапазон `[1, 30]`
     - Если есть пропуски → массив `[1, 2, 5, 7, ...]`
   - Автоматическое разбиение на группы при превышении лимита 4096 символов
   - Пример: `"100": {"1": [1, 29], "2": [1, 21]}` означает, что в сезоне 1 сериала 100 просмотрены эпизоды 1-29, в сезоне 2 - эпизоды 1-21

4. **Группированное хранение отзывов**:
   - Все отзывы на фильмы в одном ключе `movies_reviews` (объект `{id: review}`)
   - Все отзывы на сезоны в одном ключе `tv_season_reviews` (объект `{"tvId_season": review}`)
   - Автоматическое разбиение на группы при превышении лимита 4096 символов
   - Отзывы на сериалы больше не поддерживаются (только на сезоны)

#### Инициализация

```javascript
// Получение ID пользователя
let userId = sessionStorage.getItem('user_id');
if (!userId) {
    userId = window.Telegram?.WebApp?.initDataUnsafe?.user?.id;
    if (userId) {
        sessionStorage.setItem('user_id', userId);
    } else {
        userId = 'guest'; // Гостевой режим
    }
}

// Инициализация UserDataStore (автоматически):
// 1. Проверяет наличие старых данных (user_data_{userId})
// 2. Мигрирует их в новую разбитую структуру (1.4)
// 3. Проверяет и мигрирует старые ключи от предыдущей архитектуры
// 4. Удаляет старые ключи после успешной миграции
const userDataStore = new UserDataStore();
```

#### Автоматическая миграция при загрузке

При инициализации `UserDataStore` автоматически:

1. **Проверяет старые данные** (`user_data_${userId}`):
   - Если версия < 1.4 → мигрирует в разбитую структуру
   - Удаляет старый ключ после миграции

2. **Проверяет старые ключи** от предыдущей архитектуры:
   - `movies_review_{id}` → мигрирует в `movies_reviews`
   - `tv_season_review_{tvId}_{season}` → мигрирует в `tv_season_reviews`
   - `tv_ep_{tvId}` или `tv_ep_{tvId}_{season}` → мигрирует в `tv_episodes`
   - `tv_review_{id}`, `tv_reviews`, `tv_reviews_g*` → удаляет (больше не поддерживаются)
   - Удаляет все старые ключи после миграции

3. **Инициализирует метаданные** если их нет

#### Сохранение данных

Данные сохраняются автоматически при каждом изменении через `StorageAdapter`:

```javascript
// Каждое изменение автоматически сохраняется в разбитой структуре
userDataStore.addMovie('want', movie);  // Сохраняется в movies_want
userDataStore.saveReview('movie', 123, review);  // Сохраняется в movies_reviews
userDataStore.setEpisodeStatus(100, 1, 5, true);  // Сохраняется в tv_episodes

// Автоматическое разбиение на группы при превышении лимита 4096 символов
// Проверка размера выполняется автоматически
```

### 2. Кеш данных API (CacheStrategy)

#### Место хранения
- **Memory cache** (Map): Быстрый доступ, теряется при перезагрузке
- **localStorage**: `cache_${key}` - персистентный кеш с TTL (для деталей фильмов/сериалов)
- **sessionStorage**: `cache_${key}` - кеш на время сессии без TTL (для списков trending/popular)

#### Типы кешируемых данных

| Тип данных | TTL | Ключ | Хранилище |
|-----------|-----|------|-----------|
| Детали фильма | 24 часа | `movie_${id}` | localStorage |
| Детали сериала | 24 часа | `tv_${id}` | localStorage |
| Trending фильмы | - | `movies_trending` | sessionStorage |
| Popular фильмы | - | `movies_popular` | sessionStorage |
| Upcoming фильмы | - | `movies_upcoming` | sessionStorage |
| Trending сериалы | - | `tv_trending` | sessionStorage |
| Popular сериалы | - | `tv_popular` | sessionStorage |
| Top Rated сериалы | - | `tv_top_rated` | sessionStorage |
| Рекомендации | 5 минут | `movies_recommended_${ids}` | Memory only |
| Результаты поиска | Не кешируются | - | - |

#### Структура кеша

```javascript
{
    value: <данные>,           // Кешируемые данные
    timestamp: 1234567890       // Время создания в мс
}
```

#### Использование

```javascript
// Получение из localStorage (с TTL)
const cached = cacheStrategy.get('movie_123', {
    persistent: true,
    ttl: TTL.MOVIE_DETAILS
});

// Сохранение в localStorage
cacheStrategy.set('movie_123', movieData, {
    persistent: true
});

// Получение из sessionStorage (без TTL)
const trending = cacheStrategy.get('movies_trending', {
    session: true
});

// Сохранение в sessionStorage
cacheStrategy.set('movies_trending', trendingData, {
    session: true
});
```

### 3. Миграция данных (DataMigrationService)

#### Версии данных

- **v1.0**: Исходная структура (объекты по ID)
- **v1.1**: Разделение фильмов и сериалов
- **v1.2**: Разделение хранилищ фильмов и сериалов
- **v1.3**: Оптимизация - хранение только ID
- **v1.4**: Разбитая структура для CloudStorage (текущая версия)
  - Группированные отзывы (movies_reviews, tv_season_reviews)
  - Группированные эпизоды (tv_episodes)
  - Компактный формат эпизодов (диапазоны)
  - Автоматическое разбиение на группы при превышении лимита

#### Процесс миграции

1. **Проверка версии**: При загрузке данных проверяется версия
2. **Применение миграций**: Последовательно применяются все необходимые миграции (1.0 → 1.1 → 1.2 → 1.3)
3. **Миграция в разбитую структуру**: Данные мигрируются из монолитного ключа в разбитую структуру (1.3 → 1.4)
4. **Миграция старых ключей**: Автоматическая миграция старых ключей от предыдущей архитектуры
5. **Валидация**: Проверка и исправление структуры данных
6. **Удаление старых ключей**: Старые ключи удаляются после успешной миграции

#### Пример миграции 1.2 → 1.3

```javascript
// До: Хранение полных объектов
movies: {
    want: [
        { id: 1, title: "Фильм", poster_path: "/path.jpg", ... },
        { id: 2, title: "Фильм 2", ... }
    ]
}

// После: Хранение только ID
movies: {
    want: [1, 2]
}
```

#### Пример миграции 1.3 → 1.4

```javascript
// До: Монолитный ключ user_data_{userId}
{
    version: "1.3",
    movies: {
        want: [1, 2, 3],
        watched: [4, 5, 6],
        reviews: { "123": {...}, "456": {...} }
    },
    tvShows: {
        episodes: { "100_1": [1,2,3], "100_2": [1,2,3,4] },
        seasonReviews: { "100_1": {...} }
    }
}

// После: Разбитая структура
// user_{userId}_movies_want: [1, 2, 3]
// user_{userId}_movies_watched: [4, 5, 6]
// user_{userId}_movies_reviews: {"123": {...}, "456": {...}}
// user_{userId}_tv_episodes: {"100": {"1": [1,2,3], "2": [1,2,3,4]}}
// user_{userId}_tv_season_reviews: {"100_1": {...}}
```

## Работа с данными

### Добавление фильма в список

```javascript
// Добавление в "Хочу посмотреть"
userDataStore.addMovie('want', {
    id: 123,
    media_type: 'movie'
});

// Добавление в "Просмотрено"
userDataStore.addMovie('watched', {
    id: 456,
    media_type: 'movie'
});
```

### Добавление сериала в список

```javascript
// Добавление в "Хочу посмотреть"
userDataStore.addTVShow('want', {
    id: 789,
    media_type: 'tv'
});

// Добавление в "Смотрю"
userDataStore.addTVShow('watching', {
    id: 789,
    media_type: 'tv'
});
```

### Работа с эпизодами

```javascript
// Отметить эпизод как просмотренный
userDataStore.setEpisodeStatus(100, 1, 5, true);
// tvId=100, season=1, episode=5

// Проверить статус эпизода
const isWatched = userDataStore.getEpisodeStatus(100, 1, 5);

// Получить все просмотренные эпизоды сезона
const episodes = userDataStore.getSeasonEpisodes(100, 1);
// Возвращает: [1, 2, 3, 4, 5]
```

### Работа с отзывами

```javascript
// Сохранение отзыва на фильм
userDataStore.saveReview('movie', 123, {
    rating: 5,
    review: "Отличный фильм!",
    date: new Date().toISOString()
});

// Сохранение отзыва на сезон
userDataStore.saveReview('tv_season', 100, {
    rating: 5,
    review: "Отличный сезон!",
    date: new Date().toISOString()
}, 1); // seasonNumber = 1

// Получение отзыва
const review = userDataStore.getReview('movie', 123);
const seasonReview = userDataStore.getReview('tv_season', 100, 1);

// Удаление отзыва
userDataStore.removeReview('movie', 123);
userDataStore.removeReview('tv_season', 100, 1);
```

**Примечание:** Отзывы на сериалы (тип `'tv'`) больше не поддерживаются. Поддерживаются только отзывы на фильмы (`'movie'`) и сезоны (`'tv_season'`).

### Работа с недавними поисками

Недавние поиски хранятся в **sessionStorage**, а не в localStorage. Это означает, что они доступны только в пределах текущей сессии браузера и автоматически удаляются при закрытии вкладки.

```javascript
// Добавление недавнего поиска
userDataStore.addRecentSearch({
    id: 123,
    title: "Фильм",
    media_type: "movie",
    poster_path: "/path.jpg"
});

// Получение недавних поисков
const recentSearches = userDataStore.getRecentSearches();
// Возвращает массив до 10 последних поисков
```

**Особенности:**
- Хранится в `sessionStorage` с ключом `recent_searches_${userId}`
- Автоматически ограничивается до 10 записей
- Удаляется при закрытии вкладки/браузера
- Не влияет на размер localStorage

## Ограничения и оптимизация

### Ограничения localStorage

- **Максимальный размер**: ~5-10 MB (зависит от браузера)
- **Синхронный API**: Блокирует основной поток при больших операциях
- **Ограничение домена**: Данные доступны только в рамках одного домена

### Ограничения sessionStorage

Помимо очевидного минуса (очистка при закрытии вкладки), sessionStorage имеет следующие ограничения:

#### 1. Ограничение размера
- Обычно **5-10 MB** (зависит от браузера)
- Может быть меньше, чем у localStorage
- При переполнении выбрасывается `QuotaExceededError`

#### 2. Не синхронизируется между вкладками
- **Каждая вкладка имеет свой sessionStorage**
- Изменения в одной вкладке не видны в других
- В отличие от localStorage, где изменения видны во всех вкладках

```javascript
// Вкладка 1
sessionStorage.setItem('key', 'value1');

// Вкладка 2 (открыта в том же домене)
sessionStorage.getItem('key'); // null - не видит данные из вкладки 1
```

#### 3. Нет события storage
- Событие `storage` **не срабатывает** для sessionStorage
- Нельзя отслеживать изменения из других вкладок (хотя они и не видны)

```javascript
// Работает только для localStorage
window.addEventListener('storage', (e) => {
    console.log('Изменение в другой вкладке');
});
```

#### 4. Недоступен в Web Workers
- Web Workers **не имеют доступа** к sessionStorage
- Доступен только в основном потоке

#### 5. Может быть очищен браузером
- Браузер может очистить sessionStorage при **нехватке памяти**
- Особенно в мобильных браузерах
- **Нет гарантии сохранности данных**

#### 6. Проблемы в приватном режиме
- В некоторых браузерах sessionStorage может работать некорректно
- Safari в приватном режиме может блокировать запись

#### 7. Ограничения безопасности
- Только **same-origin policy**
- Нельзя делиться данными между поддоменами
- Ограничения CORS

#### 8. Синхронный API
- Блокирует основной поток при больших операциях
- Может вызывать задержки в UI

#### 9. Нет автоматического истечения
- Данные не удаляются автоматически по времени
- Только при закрытии вкладки
- Может накапливаться мусор при долгой работе

### Сравнение хранилищ

| Характеристика | sessionStorage | localStorage |
|----------------|----------------|--------------|
| Размер | 5–10 MB | 5–10 MB |
| Синхронизация между вкладками | ❌ | ✅ |
| Событие storage | ❌ | ✅ |
| Доступ в Web Workers | ❌ | ❌ |
| Очистка при закрытии | ✅ | ❌ |
| Может быть очищен браузером | ⚠️ Чаще | ⚠️ Реже |
| Приватный режим | ⚠️ Проблемы | ⚠️ Проблемы |

### Когда использовать sessionStorage

**✅ Подходит для:**
- Недавние поиски (не критичны, можно потерять)
- Списки trending/popular (можно перезапросить)
- Временные данные сессии
- Данные, которые должны быть свежими при каждом открытии

**❌ Не подходит для:**
- Пользовательские списки (want, watched, watching)
- Отзывы и рейтинги
- Прогресс просмотра эпизодов
- Любые критичные данные

### Оптимизации

1. **Хранение только ID**: Вместо полных объектов хранятся только ID
   - Экономия: ~99% места для списков фильмов/сериалов

2. **Группированное хранение отзывов и эпизодов**:
   - Все отзывы на фильмы в одном ключе `movies_reviews`
   - Все отзывы на сезоны в одном ключе `tv_season_reviews`
   - Все эпизоды всех сериалов в одном ключе `tv_episodes`
   - Автоматическое разбиение на группы при превышении лимита 4096 символов
   - **Результат**: ~10-15 ключей вместо потенциально сотен/тысяч

3. **Компактный формат эпизодов**:
   - Если все эпизоды сезона просмотрены подряд → диапазон `[1, 30]` (экономия ~95% места)
   - Если есть пропуски → массив `[1, 2, 5, 7, ...]`
   - Автоматическое определение формата

4. **Недавние поиски в sessionStorage**: Хранятся только в пределах сессии (максимум 10 записей)
   ```javascript
   // Хранится в sessionStorage, не в localStorage
   sessionStorage.setItem(`recent_searches_${userId}`, JSON.stringify(recent));
   ```

5. **Списки trending/popular в sessionStorage**: Хранятся только в пределах сессии без TTL
   ```javascript
   // Хранится в sessionStorage, автоматически очищается при закрытии вкладки
   cacheStrategy.set('movies_trending', data, { session: true });
   ```

6. **Автоматическая миграция старых ключей**: При загрузке автоматически мигрируются и удаляются старые ключи от предыдущей архитектуры

7. **Очистка неиспользуемых данных**: Утилита `StorageCleanup` для удаления:
   - Отзывов на несуществующие фильмы/сериалы
   - Старых записей поиска
   - Устаревших данных

## Обработка ошибок

### QuotaExceededError

При переполнении localStorage:

```javascript
try {
    localStorage.setItem(key, value);
} catch (error) {
    if (error.name === 'QuotaExceededError') {
        // Показываем сообщение пользователю
        window.Telegram?.WebApp?.showAlert(
            'Хранилище переполнено. Пожалуйста, очистите данные.'
        );
        
        // Отправляем событие для обработки в UI
        document.dispatchEvent(new CustomEvent('storage-quota-exceeded', {
            detail: { error, userId: this._userId }
        }));
    }
}
```

### Ошибки парсинга

При повреждении данных:

```javascript
try {
    const parsedData = JSON.parse(savedData);
} catch (error) {
    console.error('Ошибка парсинга данных:', error);
    // Создаем новое хранилище
    return this._createInitialStore();
}
```

## События

### movie-list-changed

Отправляется при изменении списков фильмов/сериалов:

```javascript
document.addEventListener('movie-list-changed', (event) => {
    const { listType, action, movie, timestamp } = event.detail;
    // listType: 'want' | 'watched' | 'watching'
    // action: 'added' | 'removed'
    // movie: объект фильма/сериала
});
```

### storage-quota-exceeded

Отправляется при переполнении хранилища:

```javascript
document.addEventListener('storage-quota-exceeded', (event) => {
    const { error, userId } = event.detail;
    // Обработка переполнения
});
```

### tg-user-data-updated

Отправляется при обновлении данных пользователя Telegram:

```javascript
document.addEventListener('tg-user-data-updated', () => {
    // Обновление userId и переинициализация хранилища
});
```

## Утилиты

### StorageCleanup

Утилиты для очистки и оптимизации данных:

```javascript
// Получить размер данных
const size = StorageCleanup.getStorageSize(userId);

// Получить статистику
const stats = StorageCleanup.getStorageStats(userId);
// {
//     totalSize: "125.50 KB",
//     version: "1.3",
//     movies: { want: 50, watched: 100, reviews: 10 },
//     tvShows: { want: 20, watching: 30, watched: 40, ... },
//     recentSearches: 5
// }

// Полная очистка
const result = StorageCleanup.fullCleanup(userId);
// {
//     before: "200.00 KB",
//     after: "150.00 KB",
//     freed: "50.00 KB"
// }

// Экспорт данных
StorageCleanup.exportData(userId);

// Импорт данных
StorageCleanup.importData(userId, file);
```

## Миграция данных

### Автоматическая миграция

Миграция выполняется автоматически при загрузке данных в `UserDataStore._initStore()`:

1. **Миграция из монолитного ключа** (`user_data_{userId}`):
   - Проверяет наличие старых данных версии < 1.4
   - Применяет миграции до версии 1.3
   - Мигрирует в разбитую структуру (1.4)
   - Удаляет старый ключ после успешной миграции

2. **Миграция старых ключей** от предыдущей архитектуры:
   - `movies_review_{id}` → `movies_reviews` (группированные)
   - `tv_season_review_{tvId}_{season}` → `tv_season_reviews` (группированные)
   - `tv_ep_{tvId}` или `tv_ep_{tvId}_{season}` → `tv_episodes` (все эпизоды в одном ключе)
   - `tv_review_{id}`, `tv_reviews`, `tv_reviews_g*` → удаляются (больше не поддерживаются)
   - Все старые ключи удаляются после миграции

```javascript
// Автоматически выполняется при инициализации UserDataStore
const userDataStore = new UserDataStore();
// Внутри:
// 1. Проверка и миграция user_data_{userId}
// 2. Проверка и миграция старых ключей
// 3. Удаление старых ключей
```

### Ручная миграция

```javascript
// Использование утилиты ремонта данных
import { dataRepair } from './services/data-repair-utility.js';

// Диагностика (проверяет старую и новую структуру)
dataRepair.diagnose(userId);

// Ремонт и миграция (с резервной копией)
dataRepair.repair(userId, backup = true);
// Выполняет:
// 1. Создание резервной копии
// 2. Миграцию до версии 1.3
// 3. Миграцию в разбитую структуру (1.4)
// 4. Удаление старых ключей
```

## Рекомендации

### Для разработчиков

1. **Всегда используйте UserDataStore** вместо прямого доступа к localStorage
2. **Проверяйте версию данных** перед использованием
3. **Используйте события** для реактивного обновления UI
4. **Мониторьте размер данных** для предотвращения переполнения

### Для пользователей

1. **Регулярно экспортируйте данные** для резервного копирования
2. **Очищайте неиспользуемые данные** при приближении к лимиту
3. **Не удаляйте данные вручную** из localStorage без резервной копии

## Будущие улучшения

### Планируемые изменения

1. **Telegram CloudStorage**: Миграция на облачное хранилище Telegram
   - ✅ Структура данных подготовлена (разбитая структура)
   - ✅ Группирование данных для минимизации ключей
   - ✅ Автоматическое разбиение на группы при превышении лимита
   - ⏳ Требуется: Рефакторинг StorageAdapter на асинхронный API
   - Синхронизация между устройствами
   - Автоматическое резервное копирование
   - Ограничение: 4096 символов на ключ (уже учтено в структуре)

2. **Инкрементальная синхронизация**: Синхронизация только изменений
3. **Сжатие данных**: Использование алгоритмов сжатия для больших данных
4. **Индексирование**: Быстрый поиск по данным

## Текущая архитектура (версия 1.4)

### Преимущества разбитой структуры

1. **Оптимизация использования ключей**:
   - ~10-15 ключей вместо потенциально сотен/тысяч
   - Группирование отзывов и эпизодов в один ключ
   - Автоматическое разбиение на группы при необходимости

2. **Подготовка к CloudStorage**:
   - Размер каждого ключа не превышает 4096 символов
   - Нормализация ключей (A-Z, a-z, 0-9, _, -)
   - Минимальное количество ключей

3. **Компактное хранение**:
   - Диапазоны для последовательных эпизодов `[1, 30]` вместо `[1,2,3,...,30]`
   - Экономия ~95% места для полностью просмотренных сезонов

4. **Автоматическая миграция**:
   - Миграция старых данных при загрузке
   - Удаление старых ключей после миграции
   - Обратная совместимость через виртуальный объект `_store`

## См. также

- [EPISODES_STORAGE_STRATEGY.md](./EPISODES_STORAGE_STRATEGY.md) - Стратегия хранения эпизодов
- [CLOUD_STORAGE_ANALYSIS.md](./CLOUD_STORAGE_ANALYSIS.md) - Анализ совместимости с CloudStorage

